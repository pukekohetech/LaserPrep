<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Laser SVG Prep — Smart Packing + PDF</title>

  <!-- PWA basics -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#cc0000">
  <meta name="description" content="Offline laser cutter SVG prep tool with smart packing and PDF export.">

  <!-- PWA manifest + icons -->
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="icons/icon-192.png">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <link rel="stylesheet" href="styles.css">
</head>
<body>

<h1>PHS - Laser SVG Prep — Smart Packing Edition</h1>
<p>Drop Inkscape SVGs → clean red lines, engraving images, smart packing, and SVG/PDF export.</p>

<div class="drop" id="dropZone">Drop SVG files here or click</div>
<input type="file" id="files" accept=".svg" multiple style="display:none">

<div class="controls">
  <div style="margin-bottom:12px;">
    Sheet size
    <input type="number" id="w" value="600" style="width:90px"> ×
    <input type="number" id="h" value="400" style="width:90px"> mm
    &nbsp;&nbsp;Student name
    <input type="text" id="studentName" placeholder="Student name" style="width:180px">
  </div>

  <hr style="margin:10px 0 15px;">

  <div style="font-weight:bold; margin-bottom:6px;">Engraving settings</div>

  <div class="slider">
    Contrast boost&nbsp;
    <span id="cVal">1.80</span>×
    <input type="range" id="contrast" min="0.5" max="5" step="0.1" value="1.8">
  </div>

  <div class="slider">
    Background cleanup&nbsp;
    <span id="bgVal">245</span>
    <input type="range" id="bgThreshold" min="200" max="255" step="1" value="245">
    <div style="font-size:0.85em; color:#555; margin-top:4px;">
      Higher = remove more light pixels (good for photos/screenshots that show boxes).
    </div>
  </div>

  <label style="display:inline-flex; align-items:center; gap:6px; font-size:0.95em; margin-top:4px;">
    <input type="checkbox" id="forceBlack" checked>
    Pure black engraving (best for line art / cartoons)
  </label>

  <div style="margin-top:16px;">
    <button id="go" disabled>Re-process All SVGs</button>
    <button id="pack" disabled>Re-pack Now</button>
    <button id="dlSvg">Download Final SVG</button>
    <button id="dlPdf">Download PDF</button>
    <button id="reset">Reset</button>
  </div>
</div>

<div id="out"></div>

<div class="info">
  <strong>Smart packing workflow:</strong>
  <ul>
    <li>Drop SVGs → they are automatically cleaned and packed</li>
    <li>Drag parts to tweak, or resize the sheet with the red corner handle</li>
    <li>When you finish resizing, parts re-pack to the new sheet size</li>
    <li>On export, you’re asked if you want to shrink the sheet to remove blank space</li>
    <li>Then you’re prompted for the student name (used in the file name)</li>
  </ul>
  100% offline • Multiple files • Exports SVG + PDF
</div>

<!-- jsPDF + svg2pdf from local copies (offline-safe) -->
<script src="jspdf.umd.min.js"></script>
<script src="svg2pdf.umd.js"></script>

<script>
/* ---------- global state ---------- */

let movers   = [];
let finalSVG = null;
let sheetW   = 600;
let sheetH   = 400;
let nextMoverId = 0;

// dragging movers
let dragState   = null;
// sheet resize
let resizeState = null;

const DISPLAY_CUT_WIDTH = 0.2;      // screen hairline
const EXPORT_CUT_WIDTH  = '0.026';  // real laser hairline (mm-ish)
const HANDLE_SIZE   = 18;           // resize handle size (mm in SVG units)
const HANDLE_MARGIN = 0;            // inset from sheet edge

/* ---------- DOM refs ---------- */

const dropZone       = document.getElementById('dropZone');
const fileInput      = document.getElementById('files');
const goBtn          = document.getElementById('go');
const packBtn        = document.getElementById('pack');
const dlSvgBtn       = document.getElementById('dlSvg');
const dlPdfBtn       = document.getElementById('dlPdf');
const resetBtn       = document.getElementById('reset');
const contrastSlider = document.getElementById('contrast');
const contrastLabel  = document.getElementById('cVal');
const bgSlider       = document.getElementById('bgThreshold');
const bgLabel        = document.getElementById('bgVal');
const forceBlackChk  = document.getElementById('forceBlack');
const out            = document.getElementById('out');
const nameInput      = document.getElementById('studentName');

/* ---------- basic UI wiring ---------- */

dropZone.onclick = () => fileInput.click();
fileInput.onchange = e => loadFiles(e.target.files);

dropZone.ondragover = e => {
  e.preventDefault();
  dropZone.classList.add('dragover');
};
dropZone.ondragleave = dropZone.ondrop = e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
};
dropZone.ondrop = e => loadFiles(e.dataTransfer.files);

contrastSlider.oninput = e => contrastLabel.textContent = e.target.value;
bgSlider.oninput       = e => bgLabel.textContent       = e.target.value;

// Manual override buttons
goBtn.onclick    = () => processAll(false);        // show alerts
packBtn.onclick  = () => doPacking(false, false);  // show alert
dlSvgBtn.onclick = downloadFinalSVG;
dlPdfBtn.onclick = downloadPDF;
resetBtn.onclick = () => location.reload();

/* ---------- helpers ---------- */

function requireStudentName() {
  const name = nameInput.value.trim();
  if (!name) {
    alert("Please enter the student's name before exporting.");
    nameInput.focus();
    return null;
  }
  return name;
}

function getFileBaseName() {
  const name = requireStudentName();
  if (!name) return null;
  let base = name.trim();
  base = base.replace(/[^\w\-]+/g, '_'); // safe-ish filename
  return `${base}_${sheetW}x${sheetH}mm`;
}

function clientToSVG(svg, clientX, clientY) {
  const pt = svg.createSVGPoint();
  pt.x = clientX;
  pt.y = clientY;
  const ctm = svg.getScreenCTM();
  if (!ctm) return { x: 0, y: 0 };
  const inv = ctm.inverse();
  const svgPt = pt.matrixTransform(inv);
  return { x: svgPt.x, y: svgPt.y };
}

async function loadFiles(files) {
  const svgFiles = [...files].filter(f => f.name.toLowerCase().endsWith('.svg'));
  if (!svgFiles.length) return;

  goBtn.disabled = false;

  // Auto process + pack when files are chosen
  await processAll(true);   // silent mode
}

/* Safe getBBox wrapper */
function safeBBox(node) {
  try {
    if (typeof node.getBBox === 'function') {
      const bb = node.getBBox();

      if (
        isFinite(bb.x) && isFinite(bb.y) &&
        isFinite(bb.width) && isFinite(bb.height) &&
        (bb.width > 0 || bb.height > 0) // allow pure horizontal/vertical lines
      ) {
        return bb;
      }
    }
  } catch (e) {}

  return null;
}

/* ---------- processing: clean SVGs into a single master ---------- */
/* silent = true → no alerts (for auto-run) */

async function processAll(silent = false) {
  if (!fileInput.files || !fileInput.files.length) {
    if (!silent) alert("No SVG files selected.");
    return;
  }

  sheetW = +document.getElementById('w').value || 600;
  sheetH = +document.getElementById('h').value || 400;

  const contrast    = +contrastSlider.value || 1.8;
  const bgThreshold = +bgSlider.value       || 245;
  const forceBlack  = !!forceBlackChk.checked;

  const master = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  master.setAttribute("width", sheetW + "mm");
  master.setAttribute("height", sheetH + "mm");
  master.setAttribute("viewBox", `0 0 ${sheetW} ${sheetH}`);

  for (const file of fileInput.files) {
    if (!file.name.toLowerCase().endsWith('.svg')) continue;
    const text = await file.text();
    const doc  = new DOMParser().parseFromString(text, "image/svg+xml");
    const svg  = doc.querySelector('svg');
    if (!svg) continue;

    // Bake simple translate() into coordinates
    svg.querySelectorAll('*').forEach(el => {
      const t = el.getAttribute('transform') || '';
      if (t.includes('translate')) {
        const m = t.match(/translate\(([^)]+)\)/);
        if (m) {
          const [dx, dy = 0] = m[1].split(/[\s,]+/).map(Number);
          ['x','x1','x2','cx'].forEach(a => { if (el.hasAttribute(a)) el.setAttribute(a, +el.getAttribute(a) + dx); });
          ['y','y1','y2','cy'].forEach(a => { if (el.hasAttribute(a)) el.setAttribute(a, +el.getAttribute(a) + dy); });
        }
        el.removeAttribute('transform');
      }
    });

    // Normalise red cut lines & tag them
    svg.querySelectorAll('*').forEach(el => {
      const rawStrokeAttr = el.getAttribute('stroke') || '';
      const rawStyle      = el.getAttribute('style') || '';

      const strokeAttr = rawStrokeAttr.toLowerCase();
      let strokeFromStyle = '';
      const styleMatch = rawStyle.toLowerCase().match(/stroke\s*:\s*([^;]+)/);
      if (styleMatch) strokeFromStyle = styleMatch[1].trim();

      const strokeValue = strokeAttr || strokeFromStyle;
      const isRed = /(#ff0000|#f00|\bred\b|rgb\s*\(\s*255\s*,\s*0\s*,\s*0\s*\))/.test(strokeValue);
      if (!isRed) return;

      // Strip stroke/fill from inline style
      if (rawStyle) {
        const cleaned = rawStyle
          .split(';')
          .map(s => s.trim())
          .filter(chunk =>
            chunk &&
            !chunk.startsWith('stroke-width') &&
            !chunk.startsWith('stroke:') &&
            !chunk.startsWith('stroke-opacity') &&
            !chunk.startsWith('fill:')
          )
          .join(';');
        if (cleaned.trim()) el.setAttribute('style', cleaned);
        else el.removeAttribute('style');
      }

      el.setAttribute('stroke', '#ff0000');
      el.setAttribute('stroke-opacity', '1');
      el.setAttribute('fill', 'none');
      el.setAttribute('stroke-width', String(DISPLAY_CUT_WIDTH));
      el.setAttribute('vector-effect', 'non-scaling-stroke');
      el.setAttribute('data-cut-line', 'true');
    });

    // Clean images: grayscale + contrast + configurable background removal
    for (const img of svg.querySelectorAll('image')) {
      let src = img.getAttribute('href') || img.getAttribute('xlink:href');
      if (src && src.startsWith('data:image')) {
        src = await new Promise(res => {
          const i = new Image();
          i.onload = () => {
            const c = document.createElement('canvas');
            c.width = i.width; c.height = i.height;
            const ctx = c.getContext('2d');

            // Apply grayscale + user contrast
            ctx.filter = `grayscale(100%) contrast(${contrast})`;
            ctx.drawImage(i, 0, 0);

            const imgData = ctx.getImageData(0,0,c.width,c.height);
            const d = imgData.data;

            for (let j = 0; j < d.length; j += 4) {
              const r = d[j], g = d[j+1], b = d[j+2];
              const gray = (r + g + b) / 3;

              if (gray > bgThreshold) {
                // Treat very light pixels as background
                d[j+3] = 0; // fully transparent
              } else if (forceBlack) {
                // For line art: turn everything else into pure black
                d[j] = d[j+1] = d[j+2] = 0;
                // d[j+3] stays as-is (or could be set to 255)
              } else {
                // Keep grayscale (after contrast) for shaded engraves
                // nothing extra to do here
              }
            }

            ctx.putImageData(imgData,0,0);
            res(c.toDataURL());
          };
          i.src = src;
        });
        img.setAttribute('href', src);
        img.removeAttribute('xlink:href');
      }
    }

    // Move all graphics into master
    svg.querySelectorAll('path,rect,circle,ellipse,polygon,polyline,line,text,image,use,g').forEach(el => {
      master.appendChild(el.cloneNode(true));
    });
  }

  // Swap in master SVG
  out.innerHTML = '';
  master.style.maxWidth = "100%";
  master.style.height   = "auto";
  out.appendChild(master);

  finalSVG    = master;
  movers      = [];
  nextMoverId = 0;

  addResizeHandle();

  await doPacking(silent, false);

  packBtn.disabled = false;
  packBtn.textContent = "Re-pack Now";

  dlSvgBtn.style.display = 'inline-block';
  dlPdfBtn.style.display = 'inline-block';

  if (!silent) {
    alert("All SVGs processed and packed.\nYou can drag parts, resize the sheet, then export as SVG or PDF.");
  }
}

/* ---------- geometry + movers ---------- */

function isShapeOrImage(el) {
  if (!el || el.nodeType !== 1) return false;
  if (el.id === 'resizeHandle') return false;
  const tag = el.tagName.toLowerCase();
  return [
    "path", "rect", "circle", "ellipse",
    "polygon", "polyline", "line",
    "image", "text"
  ].includes(tag);
}

function stripEditorAttrs(svgEl) {
  svgEl.querySelectorAll("*").forEach(el => {
    Array.from(el.attributes).forEach(attr => {
      if (attr.name.startsWith("inkscape:") ||
          attr.name.startsWith("sodipodi:")) {
        el.removeAttribute(attr.name);
      }
    });
  });
}

function propagateTransforms(rootContainer) {
  function recurse(node, accumulated) {
    const own = node.getAttribute("transform") || "";
    const combined = accumulated
      ? (own ? (accumulated + " " + own) : accumulated)
      : own;

    Array.from(node.children).forEach(child => recurse(child, combined));

    if (isShapeOrImage(node)) {
      if (combined && combined.trim() !== "") {
        node.setAttribute("transform", combined.trim());
      } else {
        node.removeAttribute("transform");
      }
    }
  }
  recurse(rootContainer, "");
  rootContainer.querySelectorAll("g").forEach(g => g.removeAttribute("transform"));
}

function explodeGroupsToShapes(rootContainer) {
  const shapes = Array.from(
    rootContainer.querySelectorAll("path, rect, circle, ellipse, polygon, polyline, line, image, text")
  );
  shapes.forEach(el => {
    if (el.parentElement !== rootContainer) {
      rootContainer.appendChild(el);
    }
  });
  Array.from(rootContainer.querySelectorAll("g")).forEach(g => g.remove());
}

function bboxesOverlap(a, b) {
  return !(
    a.x + a.width  < b.x ||
    b.x + b.width  < a.x ||
    a.y + a.height < b.y ||
    b.y + b.height < a.y
  );
}

function unionBBox(a, b) {
  if (!a) return b;
  if (!b) return a;
  const minX = Math.min(a.x, b.x);
  const minY = Math.min(a.y, b.y);
  const maxX = Math.max(a.x + a.width,  b.x + b.width);
  const maxY = Math.max(a.y + a.height, b.y + b.height);
  return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
}

function buildMoversFromOverlap(rootContainer) {
  movers = [];
  nextMoverId = 0;

  const allShapes = Array.from(
    rootContainer.querySelectorAll("path, rect, circle, ellipse, polygon, polyline, line, image, text")
  );

  // Start with one mover per element
  allShapes.forEach(el => {
    if (!isShapeOrImage(el)) return;
    const bb = safeBBox(el);
    if (!bb) return;
    const baseBBox = { x: bb.x, y: bb.y, width: bb.width, height: bb.height };
    const mbt = new Map();
    mbt.set(el, el.getAttribute("transform") || "");
    movers.push({
      id: nextMoverId++,
      members: [el],
      baseBBox,
      memberBaseTransforms: mbt,
      tx: 0,
      ty: 0
    });
  });

  // Merge overlapping movers
  let changed = true;
  while (changed) {
    changed = false;
    outer: for (let i = 0; i < movers.length; i++) {
      for (let j = i + 1; j < movers.length; j++) {
        const a = movers[i];
        const b = movers[j];
        if (bboxesOverlap(a.baseBBox, b.baseBBox)) {
          a.members = a.members.concat(b.members);
          b.members.forEach(el => {
            if (!a.memberBaseTransforms.has(el)) {
              a.memberBaseTransforms.set(el, b.memberBaseTransforms.get(el) || "");
            }
          });
          a.baseBBox = unionBBox(a.baseBBox, b.baseBBox);
          movers.splice(j, 1);
          changed = true;
          break outer;
        }
      }
    }
  }

  movers.forEach(m => {
    m.members.forEach(el => {
      el.classList.add('mover-member');
      el.dataset.moverId = String(m.id);

      el.setAttribute('pointer-events', 'bounding-box');

      // Mouse drag
      el.onmousedown = moverMouseDown;

      // Touch drag
      el.addEventListener('touchstart', moverTouchStart, { passive: false });
    });
  });
}

/* ---------- bottom-left packing ---------- */

function packBottomLeft() {
  if (!movers.length) return;

  const order = movers.slice().sort((a,b) => {
    const areaA = a.baseBBox.width * a.baseBBox.height;
    const areaB = b.baseBBox.width * b.baseBBox.height;
    return areaB - areaA;
  });

  const placed = [];

  for (const m of order) {
    const w = m.baseBBox.width;
    const h = m.baseBBox.height;

    const xs = [0];
    placed.forEach(p => {
      const xCandidate = p.x + p.width;
      if (xCandidate + w <= sheetW + 1e-6) xs.push(xCandidate);
    });

    let bestX = 0, bestY = Infinity;

    xs.forEach(x => {
      let y = 0;
      placed.forEach(p => {
        const overlapX = !(x + w <= p.x || p.x + p.width <= x);
        if (overlapX) {
          y = Math.max(y, p.y + p.height);
        }
      });
      if (y < bestY || (y === bestY && x < bestX)) {
        bestY = y;
        bestX = x;
      }
    });

    m.tx = bestX - m.baseBBox.x;
    m.ty = bestY - m.baseBBox.y;

    placed.push({ x: bestX, y: bestY, width: w, height: h, mover: m });
  }

  movers.forEach(m => applyMoverTransform(m));
}

function applyMoverTransform(m) {
  m.members.forEach(el => {
    const base = m.memberBaseTransforms.get(el) || "";
    const translatePart = `translate(${m.tx}, ${m.ty})`;
    const finalTransform = base
      ? `${base} ${translatePart}`
      : translatePart;
    el.setAttribute("transform", finalTransform.trim());
  });
}

/* ---------- fit layout into sheet ---------- */

function fitLayoutIntoSheet() {
  if (!movers.length) return true;

  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;

  movers.forEach(m => {
    const x = m.baseBBox.x + (m.tx || 0);
    const y = m.baseBBox.y + (m.ty || 0);
    const w = m.baseBBox.width;
    const h = m.baseBBox.height;

    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x + w > maxX) maxX = x + w;
    if (y + h > maxY) maxY = y + h;
  });

  const usedW = maxX - minX;
  const usedH = maxY - minY;

  const canFit = (usedW <= sheetW && usedH <= sheetH);

  const shiftX = -minX;
  const shiftY = -minY;

  movers.forEach(m => {
    m.tx += shiftX;
    m.ty += shiftY;
    applyMoverTransform(m);
  });

  return canFit;
}

/* ---------- re-pack existing movers (used on resize) ---------- */

function repackExisting(silent = true, fromResize = true) {
  if (!movers.length) return;

  packBottomLeft();
  const canFit = fitLayoutIntoSheet();

  if (fromResize && !canFit && !silent) {
    alert("Sheet is too small for all parts; some will extend beyond the boundary.");
  }

  updateResizeHandle();
}

/* ---------- packing orchestration ---------- */

async function doPacking(silent = false, fromResize = false) {
  if (!finalSVG) {
    if (!silent) alert("No SVG loaded yet.");
    return;
  }

  const root = finalSVG;

  propagateTransforms(root);
  explodeGroupsToShapes(root);
  stripEditorAttrs(finalSVG);
  buildMoversFromOverlap(root);

  if (!movers.length) {
    if (!silent) alert("No shapes/images/text found to pack.");
    return;
  }

  packBottomLeft();
  const canFit = fitLayoutIntoSheet();

  if (fromResize && !canFit && !silent) {
    alert("Sheet is too small for all parts; some will extend beyond the boundary.");
  }

  if (!silent) {
    alert("Packing complete.");
  }

  updateResizeHandle();
}

/* ---------- mover dragging + snapping ---------- */

function moverMouseDown(e) {
  if (!finalSVG) return;
  e.preventDefault();
  e.stopPropagation();

  const el = e.currentTarget;
  const id = +el.dataset.moverId;
  const m = movers.find(mm => mm.id === id);
  if (!m) return;

  const mouseSVG = clientToSVG(finalSVG, e.clientX, e.clientY);

  const curBox = {
    x: m.baseBBox.x + (m.tx || 0),
    y: m.baseBBox.y + (m.ty || 0)
  };

  dragState = {
    mover: m,
    mouseOffset: {
      x: mouseSVG.x - curBox.x,
      y: mouseSVG.y - curBox.y
    }
  };

  window.addEventListener('mousemove', moverMouseMove);
  window.addEventListener('mouseup', moverMouseUp);
}

function moverMouseMove(e) {
  if (!dragState || !finalSVG) return;
  e.preventDefault();

  const mouseSVG = clientToSVG(finalSVG, e.clientX, e.clientY);
  const m = dragState.mover;

  const boxX = mouseSVG.x - dragState.mouseOffset.x;
  const boxY = mouseSVG.y - dragState.mouseOffset.y;

  m.tx = boxX - m.baseBBox.x;
  m.ty = boxY - m.baseBBox.y;

  applyMoverTransform(m);
}

function moverMouseUp(e) {
  if (!dragState) return;
  e.preventDefault();

  const m = dragState.mover;
  snapMoverToNeighbours(m);
  applyMoverTransform(m);

  dragState = null;
  window.removeEventListener('mousemove', moverMouseMove);
  window.removeEventListener('mouseup', moverMouseUp);
}

function moverTouchStart(e) {
  if (!finalSVG) return;
  e.preventDefault();
  e.stopPropagation();

  const touch = e.touches[0];
  moverMouseDown({
    currentTarget: e.currentTarget,
    clientX: touch.clientX,
    clientY: touch.clientY,
    preventDefault: () => {},
    stopPropagation: () => {}
  });

  window.addEventListener('touchmove', moverTouchMove, { passive: false });
  window.addEventListener('touchend', moverTouchEnd);
  window.addEventListener('touchcancel', moverTouchEnd);
}

function moverTouchMove(e) {
  if (!dragState || !finalSVG) return;
  e.preventDefault();
  const touch = e.touches[0];
  moverMouseMove({
    clientX: touch.clientX,
    clientY: touch.clientY,
    preventDefault: () => {}
  });
}

function moverTouchEnd(e) {
  if (!dragState) return;
  moverMouseUp({
    preventDefault: () => {}
  });

  window.removeEventListener('touchmove', moverTouchMove);
  window.removeEventListener('touchend', moverTouchEnd);
  window.removeEventListener('touchcancel', moverTouchEnd);
}

function snapMoverToNeighbours(m) {
  const snapTol = 20;

  const mBox = {
    x: m.baseBBox.x + m.tx,
    y: m.baseBBox.y + m.ty,
    width: m.baseBBox.width,
    height: m.baseBBox.height
  };
  const mLeft   = mBox.x;
  const mRight  = mBox.x + mBox.width;
  const mTop    = mBox.y;
  const mBottom = mBox.y + mBox.height;

  let bestDx = 0, bestDxScore = Infinity;
  let bestDy = 0, bestDyScore = Infinity;

  const scoreX = (d, kind) => {
    let s = Math.abs(d);
    if (kind === "shape") s -= 1.0;
    if (kind === "sheet") s -= 0.3;
    if (d < 0) s -= 0.2; // prefer left
    return s;
  };

  const scoreY = (d, kind) => {
    let s = Math.abs(d);
    if (kind === "shape") s -= 1.0;
    if (kind === "sheet") s -= 0.3;
    if (d < 0) s -= 0.2; // prefer up
    return s;
  };

  // Snap to other movers
  movers.forEach(n => {
    if (n === m) return;
    const nBox = {
      x: n.baseBBox.x + (n.tx || 0),
      y: n.baseBBox.y + (n.ty || 0),
      width: n.baseBBox.width,
      height: n.baseBBox.height
    };
    const nLeft   = nBox.x;
    const nRight  = nBox.x + nBox.width;
    const nTop    = nBox.y;
    const nBottom = nBox.y + nBox.height;

    // X axis
    let dX = nLeft - mRight;
    if (Math.abs(dX) < snapTol) {
      const s = scoreX(dX, "shape");
      if (s < bestDxScore) { bestDxScore = s; bestDx = dX; }
    }
    dX = nRight - mLeft;
    if (Math.abs(dX) < snapTol) {
      const s = scoreX(dX, "shape");
      if (s < bestDxScore) { bestDxScore = s; bestDx = dX; }
    }

    // Y axis
    let dY = nTop - mBottom;
    if (Math.abs(dY) < snapTol) {
      const s = scoreY(dY, "shape");
      if (s < bestDyScore) { bestDyScore = s; bestDy = dY; }
    }
    dY = nBottom - mTop;
    if (Math.abs(dY) < snapTol) {
      const s = scoreY(dY, "shape");
      if (s < bestDyScore) { bestDyScore = s; bestDy = dY; }
    }
  });

  // Snap to sheet boundaries
  let dX = 0 - mLeft;
  if (Math.abs(dX) < snapTol) {
    const s = scoreX(dX, "sheet");
    if (s < bestDxScore) { bestDxScore = s; bestDx = dX; }
  }
  dX = sheetW - mRight;
  if (Math.abs(dX) < snapTol) {
    const s = scoreX(dX, "sheet");
    if (s < bestDxScore) { bestDxScore = s; bestDx = dX; }
  }

  let dY = 0 - mTop;
  if (Math.abs(dY) < snapTol) {
    const s = scoreY(dY, "sheet");
    if (s < bestDyScore) { bestDyScore = s; bestDy = dY; }
  }
  dY = sheetH - mBottom;
  if (Math.abs(dY) < snapTol) {
    const s = scoreY(dY, "sheet");
    if (s < bestDyScore) { bestDyScore = s; bestDy = dY; }
  }

  if (bestDxScore < Infinity || bestDyScore < Infinity) {
    m.tx += bestDx;
    m.ty += bestDy;
  }
}

/* ---------- resizable sheet (corner handle) ---------- */

function addResizeHandle() {
  if (!finalSVG) return;
  let handle = finalSVG.querySelector('#resizeHandle');

  if (!handle) {
    handle = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    handle.id = 'resizeHandle';
    handle.classList.add('resize-handle');

    handle.setAttribute('width', HANDLE_SIZE);
    handle.setAttribute('height', HANDLE_SIZE);

    handle.setAttribute('fill', '#c00');
    handle.setAttribute('stroke', '#c00');
    handle.setAttribute('stroke-width', '0.5');

    handle.style.cursor = 'se-resize';
    handle.style.touchAction = 'none';

    finalSVG.appendChild(handle);

    handle.addEventListener('mousedown', startSheetResize);
    handle.addEventListener('touchstart', startSheetResize, { passive: false });
  }

  updateResizeHandle();
}

function updateResizeHandle() {
  if (!finalSVG) return;
  const handle = finalSVG.querySelector('#resizeHandle');
  if (!handle) return;

  const x = sheetW - HANDLE_SIZE - HANDLE_MARGIN;
  const y = sheetH - HANDLE_SIZE - HANDLE_MARGIN;

  handle.setAttribute('x', x);
  handle.setAttribute('y', y);
}

function startSheetResize(e) {
  if (!finalSVG) return;
  e.preventDefault();
  e.stopPropagation && e.stopPropagation();

  const point = e.touches ? e.touches[0] : e;
  const pt = clientToSVG(finalSVG, point.clientX, point.clientY);

  resizeState = {
    startMouse: pt,
    startW: sheetW,
    startH: sheetH
  };

  // Mouse listeners
  window.addEventListener('mousemove', doSheetResize);
  window.addEventListener('mouseup', stopSheetResize);

  // Touch listeners
  window.addEventListener('touchmove', doSheetResize, { passive: false });
  window.addEventListener('touchend', stopSheetResize);
  window.addEventListener('touchcancel', stopSheetResize);
}

function doSheetResize(e) {
  if (!resizeState || !finalSVG) return;
  e.preventDefault && e.preventDefault();

  const point = e.touches ? e.touches[0] : e;
  const pt = clientToSVG(finalSVG, point.clientX, point.clientY);

  const dx = pt.x - resizeState.startMouse.x;
  const dy = pt.y - resizeState.startMouse.y;

  const minSize = 50;
  let newW = resizeState.startW + dx;
  let newH = resizeState.startH + dy;

  newW = Math.max(minSize, newW);
  newH = Math.max(minSize, newH);

  newW = Math.round(newW / 5) * 5;
  newH = Math.round(newH / 5) * 5;

  sheetW = newW;
  sheetH = newH;

  finalSVG.setAttribute('width', sheetW + "mm");
  finalSVG.setAttribute('height', sheetH + "mm");
  finalSVG.setAttribute('viewBox', `0 0 ${sheetW} ${sheetH}`);

  document.getElementById('w').value = sheetW;
  document.getElementById('h').value = sheetH;

  updateResizeHandle();
}

function stopSheetResize(e) {
  if (!resizeState) return;
  e && e.preventDefault && e.preventDefault();

  resizeState = null;

  window.removeEventListener('mousemove', doSheetResize);
  window.removeEventListener('mouseup', stopSheetResize);
  window.removeEventListener('touchmove', doSheetResize);
  window.removeEventListener('touchend', stopSheetResize);
  window.removeEventListener('touchcancel', stopSheetResize);

  repackExisting(true, true); // silent = true
}

/* ---------- auto-tighten sheet before export ---------- */

function computeContentBounds() {
  if (!finalSVG) return null;

  const els = finalSVG.querySelectorAll(
    "path, rect, circle, ellipse, polygon, polyline, line, image, text"
  );

  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;
  let found = false;

  els.forEach(el => {
    if (!isShapeOrImage(el)) return;
    const bb = safeBBox(el);
    if (!bb) return;
    found = true;
    minX = Math.min(minX, bb.x);
    minY = Math.min(minY, bb.y);
    maxX = Math.max(maxX, bb.x + bb.width);
    maxY = Math.max(maxY, bb.y + bb.height);
  });

  if (!found) return null;

  return {
    minX,
    minY,
    maxX,
    maxY,
    usedW: maxX - minX,
    usedH: maxY - minY
  };
}

function autoTightenSheet(bounds) {
  if (!finalSVG) return;
  const b = bounds || computeContentBounds();
  if (!b) return;

  const shiftX = -b.minX;
  const shiftY = -b.minY;

  const els = finalSVG.querySelectorAll(
    "path, rect, circle, ellipse, polygon, polyline, line, image, text"
  );

  els.forEach(el => {
    if (!isShapeOrImage(el)) return;
    const base = el.getAttribute('transform') || '';
    const extra = `translate(${shiftX}, ${shiftY})`;
    el.setAttribute('transform', (base ? base + ' ' + extra : extra).trim());
  });

  const usedW = b.usedW;
  const usedH = b.usedH;
  let newW = Math.max(50, Math.round(usedW / 5) * 5);
  let newH = Math.max(50, Math.round(usedH / 5) * 5);

  sheetW = newW;
  sheetH = newH;

  finalSVG.setAttribute('width', sheetW + "mm");
  finalSVG.setAttribute('height', sheetH + "mm");
  finalSVG.setAttribute('viewBox', `0 0 ${sheetW} ${sheetH}`);

  document.getElementById('w').value = sheetW;
  document.getElementById('h').value = sheetH;

  updateResizeHandle();
}

/* ---------- export helpers ---------- */

function prepareExportSVG() {
  if (!finalSVG) return null;

  const exportSVG = finalSVG.cloneNode(true);

  // Remove resize handle
  const handle = exportSVG.querySelector('#resizeHandle');
  if (handle) handle.remove();

  // Force all cut lines to hairline, clean styles
  exportSVG.querySelectorAll('[data-cut-line="true"]').forEach(el => {
    const rawStyle = el.getAttribute('style') || '';
    if (rawStyle) {
      const cleaned = rawStyle
        .split(';')
        .map(s => s.trim())
        .filter(chunk =>
          chunk &&
          !chunk.startsWith('stroke-width') &&
          !chunk.startsWith('stroke:') &&
          !chunk.startsWith('stroke-opacity') &&
          !chunk.startsWith('fill:')
        )
        .join(';');
      if (cleaned.trim()) el.setAttribute('style', cleaned);
      else el.removeAttribute('style');
    }

    el.setAttribute('stroke', '#ff0000');
    el.setAttribute('stroke-opacity', '1');
    el.setAttribute('fill', 'none');
    el.setAttribute('stroke-width', EXPORT_CUT_WIDTH);
    el.setAttribute('vector-effect', 'non-scaling-stroke');
  });

  exportSVG.setAttribute('width', sheetW + 'mm');
  exportSVG.setAttribute('height', sheetH + 'mm');
  exportSVG.setAttribute('viewBox', `0 0 ${sheetW} ${sheetH}`);

  return exportSVG;
}

/* ---------- SVG download ---------- */

function downloadFinalSVG() {
  if (!finalSVG) return;

  const baseName = getFileBaseName();
  if (!baseName) return;

  const exportSVG = prepareExportSVG();
  if (!exportSVG) return;

  const xml = '<?xml version="1.0" encoding="UTF-8"?>\n' +
              new XMLSerializer().serializeToString(exportSVG);

  const blob = new Blob([xml], {type:'image/svg+xml'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url;
  a.download = baseName + '.svg';
  a.click();
  URL.revokeObjectURL(url);
}

/* ---------- PDF download (jsPDF + svg2pdf) ---------- */

async function downloadPDF() {
  if (!finalSVG) return;

  const baseName = getFileBaseName();
  if (!baseName) return;

  if (!window.jspdf || !window.jspdf.jsPDF || !window.svg2pdf) {
    alert("PDF libraries not loaded. Check your internet connection or host jsPDF/svg2pdf locally.");
    return;
  }

  const exportSVG = prepareExportSVG();
  if (!exportSVG) return;

  const mmToPt = mm => mm * 72 / 25.4;
  const widthMm  = sheetW;
  const heightMm = sheetH;
  const widthPt  = mmToPt(widthMm);
  const heightPt = mmToPt(heightMm);

  const orientation = widthPt > heightPt ? "l" : "p";
  const { jsPDF } = window.jspdf;

  try {
    const pdf = new jsPDF({
      orientation,
      unit: "pt",
      format: [widthPt, heightPt],
    });

    await pdf.svg(exportSVG, {
      x: 0,
      y: 0,
      width: widthPt,
      height: heightPt
    });

    pdf.save(baseName + ".pdf");
  } catch (err) {
    console.error(err);
    alert("Error generating PDF. See console for details.");
  }
}
</script>

<!-- PWA: Register service worker for offline support -->
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
      .register('./service-worker.js')
      .catch(err => console.error('Service worker registration failed:', err));
  });
}
</script>

</body>
</html>
