<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Laser SVG Prep — Smart Packing Done Right</title>
<style>
  body {font-family:Arial,sans-serif; max-width:1100px; margin:40px auto; background:#fafafa; color:#222;}
  h1 {text-align:center; color:#c00; margin-bottom:8px;}
  h1 + p {text-align:center; font-size:1.2em; color:#555; margin-top:0;}
  .drop {
    border:4px dashed #999; padding:90px; text-align:center; background:#fff;
    border-radius:16px; margin:30px 0; cursor:pointer; font-size:1.5em; transition:.3s;
  }
  .drop.dragover {border-color:#c00; background:#ffe5e5;}
  .controls {
    background:#fff; padding:30px; border-radius:16px; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.08);
  }
  button {
    padding:16px 36px; margin:12px; font-size:18px; border:none; border-radius:12px; cursor:pointer; font-weight:bold;
  }
  #go {background:#c00; color:white;}
  #pack {background:#0066cc; color:white;}
  #dl {background:#00a000; color:white; display:none;}
  #reset {background:#666; color:white;}
  .slider {margin:20px 0; font-size:1.1em;}
  #out svg {max-width:100%; height:auto; background:white; border:3px solid #c00; border-radius:12px; box-shadow:0 10px 40px rgba(0,0,0,0.15);}
  .info {margin-top:40px; background:#f0f0f0; padding:20px; border-radius:12px; font-size:0.95em;}
</style>
</head>
<body>

<h1>Laser SVG Prep — Smart Packing Edition</h1>
<p>Drop any number of Inkscape SVGs → perfect red lines, clean engraving images, and real connected-shape packing</p>

<div class="drop" id="dropZone">Drop SVG files here or click</div>
<input type="file" id="files" accept=".svg" multiple style="display:none">

<div class="controls">
  Sheet size 
  <input type="number" id="w" value="600" style="width:90px"> ×
  <input type="number" id="h" value="400" style="width:90px"> mm

  <div class="slider">
    Engraving contrast <span id="cVal">1.80</span>×
    <input type="range" id="contrast" min="0.5" max="5" step="0.1" value="1.8">
  </div>

  <button id="go" disabled>Process & Clean All SVGs</button>
  <button id="pack" disabled>Start Smart Packing →</button>
  <button id="dl">Download Final SVG</button>
  <button id="reset">Reset</button>
</div>

<div id="out"></div>

<div class="info">
  <strong>Smart packing rules (MaxRects-style):</strong>
  <ul>
    <li>Shapes/images/text that touch or overlap are fused into a single mover</li>
    <li>Each mover is packed as a rectangle into the sheet using free-rectangles</li>
    <li>Big pieces go down first, small pieces tuck into remaining gaps</li>
    <li>Pure red cut lines, engraving-cleaned images, Inkscape junk reduced</li>
  </ul>
  100% offline • Works with multiple files • Battle-tested
</div>

<script>
let movers = [];
let finalSVG = null;
let sheetW = 600;
let sheetH = 400;

const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('files');
const goBtn = document.getElementById('go');
const packBtn = document.getElementById('pack');
const dlBtn = document.getElementById('dl');
const resetBtn = document.getElementById('reset');
const contrastSlider = document.getElementById('contrast');
const contrastLabel = document.getElementById('cVal');
const out = document.getElementById('out');

dropZone.onclick = () => fileInput.click();
fileInput.onchange = e => loadFiles(e.target.files);

dropZone.ondragover = e => {
  e.preventDefault();
  dropZone.classList.add('dragover');
};
dropZone.ondragleave = dropZone.ondrop = e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
};
dropZone.ondrop = e => loadFiles(e.dataTransfer.files);

contrastSlider.oninput = e => contrastLabel.textContent = e.target.value;

goBtn.onclick = processAll;
packBtn.onclick = runPacking;
dlBtn.onclick = downloadFinal;
resetBtn.onclick = () => location.reload();

/* ---------- file loading ---------- */

async function loadFiles(files) {
  const svgFiles = [...files].filter(f => f.name.toLowerCase().endsWith('.svg'));
  if (!svgFiles.length) return;
  goBtn.disabled = false;
}

/* ---------- helper: safe bbox ---------- */

function safeBBox(node) {
  try {
    if (typeof node.getBBox === 'function') {
      const bb = node.getBBox();
      if (isFinite(bb.x) && isFinite(bb.y) &&
          isFinite(bb.width) && isFinite(bb.height) &&
          bb.width > 0 && bb.height > 0) {
        return bb;
      }
    }
  } catch (e) {}
  return null;
}

/* ---------- process & clean all SVGs into a master SVG ---------- */

async function processAll() {
  sheetW = +document.getElementById('w').value || 600;
  sheetH = +document.getElementById('h').value || 400;
  const contrast = +document.getElementById('contrast').value;

  const master = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  master.setAttribute("width", sheetW + "mm");
  master.setAttribute("height", sheetH + "mm");
  master.setAttribute("viewBox", `0 0 ${sheetW} ${sheetH}`);

  for (const file of fileInput.files) {
    if (!file.name.toLowerCase().endsWith('.svg')) continue;
    const text = await file.text();
    const doc = new DOMParser().parseFromString(text, "image/svg+xml");
    const svg = doc.querySelector('svg');
    if (!svg) continue;

    // Simple translate baker (only handles translate())
    svg.querySelectorAll('*').forEach(el => {
      const t = el.getAttribute('transform') || '';
      if (t.includes('translate')) {
        const m = t.match(/translate\(([^)]+)\)/);
        if (m) {
          const [dx, dy = 0] = m[1].split(/[\s,]+/).map(Number);
          ['x','x1','x2','cx'].forEach(a => { if (el.hasAttribute(a)) el.setAttribute(a, +el.getAttribute(a) + dx); });
          ['y','y1','y2','cy'].forEach(a => { if (el.hasAttribute(a)) el.setAttribute(a, +el.getAttribute(a) + dy); });
        }
        el.removeAttribute('transform');
      }
    });

    // Fix red lines
    svg.querySelectorAll('*').forEach(el => {
      const stroke = (el.getAttribute('stroke') || '').toLowerCase();
      if (/ff0000|red|#f00|rgb\s*\(\s*255\s*,\s*0\s*,\s*0\s*\)/.test(stroke)) {
        el.setAttribute('stroke', '#ff0000');
        el.setAttribute('stroke-opacity', '1');
        el.setAttribute('fill', 'none');
      }
    });

    // Clean images
    for (const img of svg.querySelectorAll('image')) {
      let src = img.getAttribute('href') || img.getAttribute('xlink:href');
      if (src && src.startsWith('data:image')) {
        src = await new Promise(res => {
          const i = new Image();
          i.onload = () => {
            const c = document.createElement('canvas');
            c.width = i.width; c.height = i.height;
            const ctx = c.getContext('2d');
            ctx.filter = `grayscale(100%) contrast(${contrast})`;
            ctx.drawImage(i, 0, 0);

            const imgData = ctx.getImageData(0,0,c.width,c.height);
            const d = imgData.data;
            for (let j=0; j<d.length; j+=4) {
              const gray = (d[j] + d[j+1] + d[j+2]) / 3;
              if (gray > 235) d[j+3] = 0;
            }
            ctx.putImageData(imgData,0,0);
            res(c.toDataURL());
          };
          i.src = src;
        });
        img.setAttribute('href', src);
        img.removeAttribute('xlink:href');
      }
    }

    // Collect all graphical elements into master
    svg.querySelectorAll('path,rect,circle,ellipse,polygon,polyline,line,text,image,use,g').forEach(el => {
      master.appendChild(el.cloneNode(true));
    });
  }

  out.innerHTML = '';
  master.style.maxWidth = "100%";
  master.style.height = "auto";
  out.appendChild(master);

  finalSVG = master;
  movers = [];

  alert("All SVGs processed & cleaned.\nNow click “Start Smart Packing →” to pack them.");

  packBtn.disabled = false;
  dlBtn.style.display = 'inline-block';
}

/* ---------- geometry helpers for packing ---------- */

function isShapeOrImage(el) {
  if (!el || el.nodeType !== 1) return false;
  const tag = el.tagName.toLowerCase();
  return [
    "path", "rect", "circle", "ellipse",
    "polygon", "polyline", "image", "text"
  ].includes(tag);
}

function stripEditorAttrs(svgEl) {
  const all = svgEl.querySelectorAll("*");
  all.forEach(el => {
    const attrs = Array.from(el.attributes);
    attrs.forEach(attr => {
      if (attr.name.startsWith("inkscape:") ||
          attr.name.startsWith("sodipodi:")) {
        el.removeAttribute(attr.name);
      }
    });
  });
}

/* Push all group transforms down onto shapes/images/text. */
function propagateTransforms(rootContainer) {
  function recurse(node, accumulated) {
    const own = node.getAttribute("transform") || "";
    const combined = accumulated
      ? (own ? (accumulated + " " + own) : accumulated)
      : own;

    Array.from(node.children).forEach(child => {
      recurse(child, combined);
    });

    if (isShapeOrImage(node)) {
      if (combined && combined.trim() !== "") {
        node.setAttribute("transform", combined.trim());
      } else {
        node.removeAttribute("transform");
      }
    }
  }

  recurse(rootContainer, "");

  const groups = rootContainer.querySelectorAll("g");
  groups.forEach(g => g.removeAttribute("transform"));
}

/* Move all shapes/images/text to rootContainer & remove internal groups. */
function explodeGroupsToShapes(rootContainer) {
  const shapes = Array.from(
    rootContainer.querySelectorAll("path, rect, circle, ellipse, polygon, polyline, image, text")
  );

  shapes.forEach(el => {
    if (el.parentElement !== rootContainer) {
      rootContainer.appendChild(el);
    }
  });

  const groups = Array.from(rootContainer.querySelectorAll("g"));
  groups.forEach(g => g.remove());
}

/* Merge movers whose bboxes touch or overlap (touch counts as overlap). */
function bboxesOverlap(a, b) {
  return !(
    a.x + a.width  < b.x ||
    b.x + b.width  < a.x ||
    a.y + a.height < b.y ||
    b.y + b.height < a.y
  );
}

function unionBBox(a, b) {
  if (!a) return b;
  if (!b) return a;
  const minX = Math.min(a.x, b.x);
  const minY = Math.min(a.y, b.y);
  const maxX = Math.max(a.x + a.width,  b.x + b.width);
  const maxY = Math.max(a.y + a.height, b.y + b.height);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}

/* Build movers from overlapping/touching shapes, images, and text. */
function buildMoversFromOverlap(rootContainer) {
  movers = [];

  const allShapes = Array.from(
    rootContainer.querySelectorAll("path, rect, circle, ellipse, polygon, polyline, image, text")
  );

  allShapes.forEach(el => {
    const bb = safeBBox(el);
    if (!bb) return;
    const baseBBox = { x: bb.x, y: bb.y, width: bb.width, height: bb.height };
    const mbt = new Map();
    mbt.set(el, el.getAttribute("transform") || "");
    movers.push({
      members: [el],
      baseBBox,
      memberBaseTransforms: mbt,
      tx: 0,
      ty: 0
    });
  });

  let changed = true;
  while (changed) {
    changed = false;
    outer: for (let i = 0; i < movers.length; i++) {
      for (let j = i + 1; j < movers.length; j++) {
        const a = movers[i];
        const b = movers[j];
        if (bboxesOverlap(a.baseBBox, b.baseBBox)) {
          a.members = a.members.concat(b.members);
          b.members.forEach(el => {
            if (!a.memberBaseTransforms.has(el)) {
              a.memberBaseTransforms.set(el, b.memberBaseTransforms.get(el) || "");
            }
          });
          a.baseBBox = unionBBox(a.baseBBox, b.baseBBox);
          movers.splice(j, 1);
          changed = true;
          break outer;
        }
      }
    }
  }
}

/* ---------- MaxRects-style free-rectangle packing ---------- */

// Remove any free rect that is fully contained in another
function pruneFreeRects(freeRects) {
  for (let i = 0; i < freeRects.length; i++) {
    const a = freeRects[i];
    for (let j = 0; j < freeRects.length; j++) {
      if (i === j) continue;
      const b = freeRects[j];
      if (a.x >= b.x &&
          a.y >= b.y &&
          a.x + a.width  <= b.x + b.width &&
          a.y + a.height <= b.y + b.height) {
        freeRects.splice(i, 1);
        i--;
        break;
      }
    }
  }
}

/* Place movers as rectangles inside sheet via free-rectangles. */
function packWithFreeRects() {
  if (!movers.length) return;

  // Sort movers by area descending (big pieces first)
  movers.sort((a, b) => {
    const aa = a.baseBBox.width * a.baseBBox.height;
    const bb = b.baseBBox.width * b.baseBBox.height;
    return bb - aa;
  });

  // Initial free space is the whole sheet
  const freeRects = [{
    x: 0,
    y: 0,
    width: sheetW,
    height: sheetH
  }];

  for (const m of movers) {
    const w = m.baseBBox.width;
    const h = m.baseBBox.height;

    let bestRectIndex = -1;
    let bestScore = Infinity;
    let bestX = 0;
    let bestY = 0;

    // Find best free rect this mover can fit into
    for (let i = 0; i < freeRects.length; i++) {
      const fr = freeRects[i];
      if (w <= fr.width && h <= fr.height) {
        // Simple score: leftover area after placement
        const leftoverW = fr.width - w;
        const leftoverH = fr.height - h;
        const score = leftoverW * leftoverH;
        if (score < bestScore) {
          bestScore = score;
          bestRectIndex = i;
          bestX = fr.x;
          bestY = fr.y;
        }
      }
    }

    if (bestRectIndex === -1) {
      // No free rect could hold it; fallback: leave in original position
      // tx,ty = 0 in this case
      continue;
    }

    const fr = freeRects[bestRectIndex];

    // Place mover at (bestX, bestY)
    m.tx = bestX - m.baseBBox.x;
    m.ty = bestY - m.baseBBox.y;

    // Split the used rect into right & bottom pieces
    const usedW = w;
    const usedH = h;

    const newRects = [];

    // Right side
    const rightW = fr.width - usedW;
    if (rightW > 0) {
      newRects.push({
        x: fr.x + usedW,
        y: fr.y,
        width: rightW,
        height: usedH
      });
    }

    // Bottom side
    const bottomH = fr.height - usedH;
    if (bottomH > 0) {
      newRects.push({
        x: fr.x,
        y: fr.y + usedH,
        width: fr.width,
        height: bottomH
      });
    }

    // Remove used rect, add new ones
    freeRects.splice(bestRectIndex, 1);
    freeRects.push(...newRects);

    pruneFreeRects(freeRects);
  }

  // Apply transforms to members based on tx,ty
  movers.forEach(m => {
    m.members.forEach(el => {
      const base = m.memberBaseTransforms.get(el) || "";
      const translatePart = `translate(${m.tx}, ${m.ty})`;
      const finalTransform = base
        ? `${base} ${translatePart}`
        : translatePart;
      el.setAttribute("transform", finalTransform.trim());
    });
  });
}

/* ---------- Run packing on current master SVG ---------- */

function runPacking() {
  if (!finalSVG) {
    alert("No SVG loaded yet.");
    return;
  }

  const svgEl = finalSVG;
  const rootContainer = svgEl;

  propagateTransforms(rootContainer);
  explodeGroupsToShapes(rootContainer);
  stripEditorAttrs(svgEl);
  buildMoversFromOverlap(rootContainer);

  if (!movers.length) {
    alert("No shapes/images/text found to pack.");
    return;
  }

  packWithFreeRects();

  alert("Packing complete.");
  packBtn.disabled = true;
  packBtn.textContent = "Packing Complete!";
}

/* ---------- download ---------- */

function downloadFinal() {
  if (!finalSVG) return;
  const xml = '<?xml version="1.0" encoding="UTF-8"?>\n' +
              new XMLSerializer().serializeToString(finalSVG);
  const blob = new Blob([xml], {type:'image/svg+xml'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'laser-perfect-packed.svg';
  a.click();
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>
