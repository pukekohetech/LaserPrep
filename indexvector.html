<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Laser SVG Prep â€” Smart Packing Edition</title>
<style>
  body {
    font-family:Arial,sans-serif;
    max-width:1100px;
    margin:40px auto;
    background:#fafafa;
    color:#222;
  }
  h1 {text-align:center; color:#c00; margin-bottom:8px;}
  h1 + p {text-align:center; font-size:1.2em; color:#555; margin-top:0;}
  .drop {
    border:4px dashed #999; padding:90px; text-align:center; background:#fff;
    border-radius:16px; margin:30px 0; cursor:pointer; font-size:1.5em; transition:.3s;
  }
  .drop.dragover {border-color:#c00; background:#ffe5e5;}
  .controls {
    background:#fff; padding:30px; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.08);
  }
  button {
    padding:16px 36px; margin:8px; font-size:16px; border:none; border-radius:12px; cursor:pointer; font-weight:bold;
  }
  #go {background:#c00; color:white;}
  #pack {background:#0066cc; color:white;}
  #dlSvg {background:#00a000; color:white; display:none;}
  #dlPdf {background:#008858; color:white; display:none;}
  #reset {background:#666; color:white;}
  #debugMovers {background:#999; color:white; font-size:14px; padding:10px 18px;}
  .slider {margin:20px 0; font-size:1.1em;}

  #out svg {
    max-width:100%;
    height:auto;
    background:white;
    border:3px solid #c00;
    border-radius:12px;
    box-shadow:0 10px 40px rgba(0,0,0,0.15);
  }

  .info {
    margin-top:40px;
    background:#f0f0f0;
    padding:20px;
    border-radius:12px;
    font-size:0.95em;
  }

  .mover-member { cursor: move; }
  .resize-handle { cursor: se-resize; }
</style>
</head>
<body>
<h1>Laser SVG Prep â€” Smart Packing Edition</h1>
<p>Drop any number of Inkscape SVGs â†’ red 0.026&nbsp;mm cut lines, vectorised engravings, smart packing, and PDF export.</p>

<div class="drop" id="dropZone">Drop SVG files here or click</div>
<input type="file" id="files" accept=".svg" multiple style="display:none">

<div class="controls">
  Sheet sizeâ€ƒ
  <input type="number" id="w" value="600" style="width:90px"> Ã—
  <input type="number" id="h" value="400" style="width:90px"> mm
  &nbsp;&nbsp;Student name
  <input type="text" id="studentName" placeholder="Student name" style="width:180px">

  <div class="slider">
    Engraving contrastâ€ƒ<span id="cVal">1.80</span>Ã—
    <input type="range" id="contrast" min="0.5" max="5" step="0.1" value="1.8">
  </div>

  <button id="go" disabled>Process & Clean All SVGs</button>
  <button id="pack" disabled>Start Smart Packing â†’</button>
  <button id="dlSvg">Download Final SVG</button>
  <button id="dlPdf">Download PDF</button>
  <button id="reset">Reset</button>
  <button id="debugMovers">Debug movers â†’ clipboard</button>
</div>

<div id="out"></div>

<div class="info">
  <strong>Pipeline:</strong>
  <ul>
    <li>Clean + unify pure red cut lines (on-screen â‰ˆ0.2, export = <strong>0.026&nbsp;mm</strong>)</li>
    <li>Grayscale + contrast images, then vectorise them immediately</li>
    <li>Smart bottom-left packing with snapping and resizable sheet</li>
    <li>Only the main cut outline per part is draggable; engravings move with it</li>
    <li>Export SVG or PDF (page size = sheet size) named with student + sheet</li>
  </ul>
</div>

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.2.0/dist/svg2pdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.min.js"></script>

<script>
let movers = [];
let finalSVG = null;
let sheetW = 600;
let sheetH = 400;
let nextMoverId = 0;

let selectedMover = null;
let dragState = null;
let resizeState = null;

const dropZone       = document.getElementById('dropZone');
const fileInput      = document.getElementById('files');
const goBtn          = document.getElementById('go');
const packBtn        = document.getElementById('pack');
const dlSvgBtn       = document.getElementById('dlSvg');
const dlPdfBtn       = document.getElementById('dlPdf');
const resetBtn       = document.getElementById('reset');
const debugMoversBtn = document.getElementById('debugMovers');
const contrastSlider = document.getElementById('contrast');
const contrastLabel  = document.getElementById('cVal');
const out            = document.getElementById('out');
const nameInput      = document.getElementById('studentName');

const DISPLAY_CUT_WIDTH = 0.2;
const EXPORT_CUT_WIDTH  = '0.026';

dropZone.onclick = () => fileInput.click();
fileInput.onchange = e => loadFiles(e.target.files);

dropZone.ondragover = e => {
  e.preventDefault();
  dropZone.classList.add('dragover');
};
dropZone.ondragleave = dropZone.ondrop = e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
};
dropZone.ondrop = e => loadFiles(e.dataTransfer.files);

contrastSlider.oninput = e => contrastLabel.textContent = e.target.value;

goBtn.onclick          = processAll;
packBtn.onclick        = () => doPacking(false, false);
dlSvgBtn.onclick       = downloadFinalSVG;
dlPdfBtn.onclick       = downloadPDF;
resetBtn.onclick       = () => location.reload();
debugMoversBtn.onclick = copyMoversDebugToClipboard;

function requireStudentName() {
  const name = nameInput.value.trim();
  if (!name) {
    alert("Please enter the student's name before exporting.");
    nameInput.focus();
    return null;
  }
  return name;
}

function clientToSVG(svg, clientX, clientY) {
  const pt = svg.createSVGPoint();
  pt.x = clientX;
  pt.y = clientY;
  const ctm = svg.getScreenCTM();
  if (!ctm) return { x: 0, y: 0 };
  const inv = ctm.inverse();
  const svgPt = pt.matrixTransform(inv);
  return { x: svgPt.x, y: svgPt.y };
}

async function loadFiles(files) {
  const svgFiles = [...files].filter(f => f.name.toLowerCase().endsWith('.svg'));
  if (!svgFiles.length) return;
  goBtn.disabled = false;
}

function safeBBox(node) {
  try {
    if (typeof node.getBBox === 'function') {
      const bb = node.getBBox();
      if (isFinite(bb.x) && isFinite(bb.y) &&
          isFinite(bb.width) && isFinite(bb.height) &&
          bb.width > 0 && bb.height > 0) {
        return bb;
      }
    }
  } catch (e) {}
  return null;
}

/* --- NEW: remove duplicated elements (by id and Bart clones) --- */
/* --- NEW: remove duplicated elements (by id, Bart clones, and duplicate cuts) --- */
function dedupeSvgElements(svgRoot) {
  const seenIds = new Set();
  const seenImagePaths = new Set();

  const all = [
    ...svgRoot.querySelectorAll(
      'rect, ellipse, path, text, circle, polygon, polyline, line, image, g'
    )
  ];

  // 1) simple id + data-from-image dedupe (as before)
  for (const el of all) {
    const id = el.getAttribute('id');

    // Only keep the first element with a given id
    if (id) {
      if (seenIds.has(id)) {
        el.remove();
        continue;
      }
      seenIds.add(id);
    }

    // data-from-image (Bart etc): dedupe exact d+transform
    if (el.matches && el.matches('path[data-from-image="true"]')) {
      const sig =
        (el.getAttribute('d') || '') +
        '|' +
        (el.getAttribute('transform') || '');
      if (seenImagePaths.has(sig)) {
        el.remove();
        continue;
      }
      seenImagePaths.add(sig);
    }
  }

  // 2) EXTRA: dedupe duplicate CUT paths with same d + almost same bbox
  const cutPaths = Array.from(
    svgRoot.querySelectorAll('path[data-cut-line="true"]')
  );

  function bboxOrNull(node) {
    try {
      if (typeof node.getBBox === 'function') {
        const bb = node.getBBox();
        if (
          isFinite(bb.x) && isFinite(bb.y) &&
          isFinite(bb.width) && isFinite(bb.height) &&
          bb.width > 0 && bb.height > 0
        ) {
          return bb;
        }
      }
    } catch (e) {}
    return null;
  }

  for (let i = 0; i < cutPaths.length; i++) {
    const a = cutPaths[i];
    if (!a || !a.parentNode) continue;

    const dA = a.getAttribute('d') || '';
    if (!dA) continue;

    const bbA = bboxOrNull(a);
    if (!bbA) continue;

    const areaA = bbA.width * bbA.height;
    const cxA = bbA.x + bbA.width / 2;
    const cyA = bbA.y + bbA.height / 2;

    for (let j = i + 1; j < cutPaths.length; j++) {
      const b = cutPaths[j];
      if (!b || !b.parentNode) continue;

      const dB = b.getAttribute('d') || '';
      if (dB !== dA) continue; // only care about identical geometry

      const bbB = bboxOrNull(b);
      if (!bbB) continue;

      const areaB = bbB.width * bbB.height;
      if (!areaA || !areaB) continue;

      const areaRatio = Math.max(areaA, areaB) / Math.min(areaA, areaB);
      const cxB = bbB.x + bbB.width / 2;
      const cyB = bbB.y + bbB.height / 2;
      const dx = Math.abs(cxA - cxB);
      const dy = Math.abs(cyA - cyB);

      // tweak tolerances if needed:
      const sameSize   = areaRatio < 1.02; // within ~2%
      const sameCentre = dx < 0.5 && dy < 0.5; // almost exactly on top

      if (sameSize && sameCentre) {
        // remove the later one (b), keep a
        b.remove();
      }
    }
  }
}


/* ---------- process & clean all SVGs ---------- */

async function processAll() {
  sheetW = +document.getElementById('w').value || 600;
  sheetH = +document.getElementById('h').value || 400;
  const contrast = +document.getElementById('contrast').value;

  const master = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  master.setAttribute("width", sheetW + "mm");
  master.setAttribute("height", sheetH + "mm");
  master.setAttribute("viewBox", `0 0 ${sheetW} ${sheetH}`);
  master.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  master.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");

  for (const file of fileInput.files) {
    if (!file.name.toLowerCase().endsWith('.svg')) continue;
    const text = await file.text();
    const doc  = new DOMParser().parseFromString(text, "image/svg+xml");
    const svg  = doc.querySelector('svg');
    if (!svg) continue;

    // inline translate into geometry attrs
   // inline translate into geometry attrs
svg.querySelectorAll('*').forEach(el => {
  // ðŸš« Never touch transforms on traced-image paths like Bart
  if (el.getAttribute('data-from-image') === 'true') return;

  const t = el.getAttribute('transform') || '';
  if (t.includes('translate')) {
    const m = t.match(/translate\(([^)]+)\)/);
    if (m) {
      const [dx, dy = 0] = m[1].split(/[\s,]+/).map(Number);
      ['x','x1','x2','cx'].forEach(a => {
        if (el.hasAttribute(a)) el.setAttribute(a, +el.getAttribute(a) + dx);
      });
      ['y','y1','y2','cy'].forEach(a => {
        if (el.hasAttribute(a)) el.setAttribute(a, +el.getAttribute(a) + dy);
      });
    }

    // You *could* be more clever and only strip the translate() part,
    // but for now this keeps your old behaviour for everything except
    // data-from-image shapes.
    el.removeAttribute('transform');
  }
});


    // fix red lines
    svg.querySelectorAll('*').forEach(el => {
      const rawStrokeAttr = el.getAttribute('stroke') || '';
      const rawStyle      = el.getAttribute('style') || '';
      const strokeAttr    = rawStrokeAttr.toLowerCase();

      let strokeFromStyle = '';
      const styleLower = rawStyle.toLowerCase();
      const strokeStyleMatch = styleLower.match(/stroke\s*:\s*([^;]+)/);
      if (strokeStyleMatch) {
        strokeFromStyle = strokeStyleMatch[1].trim();
      }
      const strokeValue = strokeAttr || strokeFromStyle;
      const isRed = /(#ff0000|#f00|\bred\b|rgb\s*\(\s*255\s*,\s*0\s*,\s*0\s*\))/.test(strokeValue);
      if (!isRed) return;

      if (rawStyle) {
        const cleaned = rawStyle
          .split(';')
          .map(s => s.trim())
          .filter(chunk =>
            chunk &&
            !chunk.startsWith('stroke-width') &&
            !chunk.startsWith('stroke:') &&
            !chunk.startsWith('stroke-opacity') &&
            !chunk.startsWith('fill:')
          )
          .join(';');
        if (cleaned.trim()) el.setAttribute('style', cleaned);
        else el.removeAttribute('style');
      }

      el.removeAttribute('stroke-width');
      el.removeAttribute('stroke-opacity');
      el.removeAttribute('fill');

      el.setAttribute('stroke', '#ff0000');
      el.setAttribute('stroke-opacity', '1');
      el.setAttribute('fill', 'none');
      el.setAttribute('stroke-width', String(DISPLAY_CUT_WIDTH));
      el.setAttribute('vector-effect', 'non-scaling-stroke');
      el.setAttribute('data-cut-line', 'true');
    });

    // grayscale + contrast bitmap images
    for (const img of svg.querySelectorAll('image')) {
      let src = img.getAttribute('href') || img.getAttribute('xlink:href');
      if (src && src.startsWith('data:image')) {
        src = await new Promise(res => {
          const i = new Image();
          i.onload = () => {
            const c = document.createElement('canvas');
            c.width = i.width; c.height = i.height;
            const ctx = c.getContext('2d');
            ctx.filter = `grayscale(100%) contrast(${contrast})`;
            ctx.drawImage(i, 0, 0);
            res(c.toDataURL());
          };
          i.src = src;
        });
        img.setAttribute('href', src);
        img.removeAttribute('xlink:href');
      }
    }

    // append shapes into master
    svg.querySelectorAll('path,rect,circle,ellipse,polygon,polyline,line,text,image,use,g').forEach(el => {
      master.appendChild(el.cloneNode(true));
    });
  }

  // ðŸ”´ NEW: remove duplicates by id and image-path signature
  dedupeSvgElements(master);

  out.innerHTML = '';
  master.style.maxWidth = "100%";
  master.style.height   = "auto";
  out.appendChild(master);

  finalSVG = master;
  movers   = [];
  nextMoverId = 0;

  addResizeHandle();

  finalSVG.addEventListener('mousedown', e => {
    if (e.target === finalSVG) setSelectedMover(null);
  });

  await vectoriseImages(true);

  alert("All SVGs processed, images vectorised. Now click â€œStart Smart Packing â†’â€.");

  packBtn.disabled       = false;
  dlSvgBtn.style.display = 'inline-block';
  dlPdfBtn.style.display = 'inline-block';
}

/* ---------- geometry / movers ---------- */

function isShapeOrImage(el) {
  if (!el || el.nodeType !== 1) return false;
  if (el.id === 'resizeHandle') return false;
  const tag = el.tagName.toLowerCase();
  return [
    "path", "rect", "circle", "ellipse",
    "polygon", "polyline", "line",
    "image", "text"
  ].includes(tag);
}

function stripEditorAttrs(svgEl) {
  svgEl.querySelectorAll("*").forEach(el => {
    Array.from(el.attributes).forEach(attr => {
      if (attr.name.startsWith("inkscape:") ||
          attr.name.startsWith("sodipodi:")) {
        el.removeAttribute(attr.name);
      }
    });
  });
}

function propagateTransforms(rootContainer) {
  function recurse(node, accumulated) {
    const own = node.getAttribute("transform") || "";
    const combined = accumulated
      ? (own ? (accumulated + " " + own) : accumulated)
      : own;

    Array.from(node.children).forEach(child => recurse(child, combined));

    if (isShapeOrImage(node)) {
      if (combined && combined.trim() !== "") {
        node.setAttribute("transform", combined.trim());
      } else {
        node.removeAttribute("transform");
      }
    }
  }
  recurse(rootContainer, "");
  rootContainer.querySelectorAll("g").forEach(g => g.removeAttribute("transform"));
}

function explodeGroupsToShapes(rootContainer) {
  const shapes = Array.from(
    rootContainer.querySelectorAll("path, rect, circle, ellipse, polygon, polyline, line, image, text")
  );
  shapes.forEach(el => {
    if (el.parentElement !== rootContainer) {
      rootContainer.appendChild(el);
    }
  });
  Array.from(rootContainer.querySelectorAll("g")).forEach(g => g.remove());
}

function bboxesOverlap(a, b) {
  return !(
    a.x + a.width  < b.x ||
    b.x + b.width  < a.x ||
    a.y + a.height < b.y ||
    b.y + b.height < a.y
  );
}

function unionBBox(a, b) {
  if (!a) return b;
  if (!b) return a;
  const minX = Math.min(a.x, a.x + a.width, b.x, b.x + b.width);
  const minY = Math.min(a.y, a.y + a.height, b.y, b.y + b.height);
  const maxX = Math.max(a.x, a.x + a.width, b.x, b.x + b.width);
  const maxY = Math.max(a.y, a.y + a.height, b.y, b.y + b.height);
  return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
}


// intersection area of two bboxes (0 if none)
function bboxIntersectionArea(a, b) {
  const x1 = Math.max(a.x, b.x);
  const y1 = Math.max(a.y, b.y);
  const x2 = Math.min(a.x + a.width,  b.x + b.width);
  const y2 = Math.min(a.y + a.height, b.y + b.height);
  if (x2 <= x1 || y2 <= y1) return 0;
  return (x2 - x1) * (y2 - y1);
}



function setSelectedMover(m) { selectedMover = m; }

/* ---------- build movers ---------- */

function buildMoversFromOverlap(rootContainer) {
  movers = [];
  nextMoverId = 0;

  const allShapes = Array.from(
    rootContainer.querySelectorAll(
      "path, rect, circle, ellipse, polygon, polyline, line, image, text"
    )
  ).filter(isShapeOrImage);

  const shapeInfos = [];
  allShapes.forEach(el => {
    const bb = safeBBox(el);
    if (!bb) return;
    shapeInfos.push({
      el,
      bb,
      isCut: el.getAttribute("data-cut-line") === "true"
    });
  });


//const otherInfos = shapeInfos.filter(s => !s.isCut);
  const cutInfos   = shapeInfos.filter(s => s.isCut);
  const otherInfos = shapeInfos.filter(s => !s.isCut);

  // ---------- fallback: no cut lines at all ----------
  if (!cutInfos.length) {
    shapeInfos.forEach(info => {
      const mbt = new Map();
      mbt.set(info.el, info.el.getAttribute("transform") || "");
      movers.push({
        id: nextMoverId++,
        members: [info.el],
        baseBBox: {
          x: info.bb.x,
          y: info.bb.y,
          width: info.bb.width,
          height: info.bb.height
        },
        memberBaseTransforms: mbt,
        tx: 0,
        ty: 0,
        hasCut: false
      });
    });

    // merge overlapping movers (for pure engrave jobs)
    let changed = true;
    while (changed) {
      changed = false;
      outer_fb: for (let i = 0; i < movers.length; i++) {
        for (let j = i + 1; j < movers.length; j++) {
          const a = movers[i];
          const b = movers[j];
          if (bboxesOverlap(a.baseBBox, b.baseBBox)) {
            a.members = a.members.concat(b.members);
            b.members.forEach(el => {
              if (!a.memberBaseTransforms.has(el)) {
                a.memberBaseTransforms.set(
                  el,
                  b.memberBaseTransforms.get(el) || ""
                );
              }
            });
            a.baseBBox = unionBBox(a.baseBBox, b.baseBBox);
            movers.splice(j, 1);
            changed = true;
            break outer_fb;
          }
        }
      }
    }

    markMoverHandles();
    return;
  }

  // ---------- normal case: we have red cut lines ----------

  function bboxContains(bb, x, y, pad = 0) {
    return (
      x >= bb.x - pad &&
      x <= bb.x + bb.width + pad &&
      y >= bb.y - pad &&
      y <= bb.y + bb.height + pad
    );
  }

  // decorate cutInfos
  cutInfos.forEach(info => {
    info.cx = info.bb.x + info.bb.width  / 2;
    info.cy = info.bb.y + info.bb.height / 2;
    info.area = info.bb.width * info.bb.height;
    info.container = null;
  });

  // find containing cut for each smaller cut
  cutInfos.forEach(info => {
    let bestContainer = null;
    cutInfos.forEach(other => {
      if (other === info) return;
      if (other.area <= info.area) return;
      if (!bboxContains(other.bb, info.cx, info.cy, 0.01)) return;
      if (!bestContainer || other.area < bestContainer.area) {
        bestContainer = other;
      }
    });
    info.container = bestContainer;
  });

  // primary cut = no container
  const primaryCuts = cutInfos.filter(ci => !ci.container);
  const childCutsByPrimary = new Map();
  primaryCuts.forEach(ci => childCutsByPrimary.set(ci, []));
  cutInfos.forEach(ci => {
    if (ci.container) {
      const arr = childCutsByPrimary.get(ci.container);
      if (arr) arr.push(ci);
    }
  });

  const moverByElement = new Map();

  // 1) primary cut â†’ mover (baseBBox from CUTS ONLY)
  primaryCuts.forEach(info => {
    const mbt = new Map();
    mbt.set(info.el, info.el.getAttribute("transform") || "");

    let baseBBox = {
      x: info.bb.x,
      y: info.bb.y,
      width: info.bb.width,
      height: info.bb.height
    };

    const members = [info.el];

    const children = childCutsByPrimary.get(info) || [];
    children.forEach(child => {
      members.push(child.el);
      mbt.set(child.el, child.el.getAttribute("transform") || "");
      // child is also a CUT â†’ union into baseBBox
      baseBBox = unionBBox(baseBBox, child.bb);
    });

    const m = {
      id: nextMoverId++,
      members,
      baseBBox,
      memberBaseTransforms: mbt,
      tx: 0,
      ty: 0,
      hasCut: true
    };
    movers.push(m);
    members.forEach(el => moverByElement.set(el, m));
  });

otherInfos.forEach(info => {
  const bb = info.bb;

  // find center of this engrave
  const center = {
    x: bb.x + bb.width / 2,
    y: bb.y + bb.height / 2
  };

  let bestMover = null;
  let bestScore = Infinity;

  // 1) try to find an overlapping primary cut
  primaryCuts.forEach(cutInfo => {
    const m = moverByElement.get(cutInfo.el);
    if (!m) return;

    // if their bboxes don't overlap at all, skip
    if (!bboxesOverlap(bb, cutInfo.bb)) return;

    const ccx = cutInfo.bb.x + cutInfo.bb.width / 2;
    const ccy = cutInfo.bb.y + cutInfo.bb.height / 2;
    const dx = center.x - ccx;
    const dy = center.y - ccy;
    const dist2 = dx * dx + dy * dy;

    if (dist2 < bestScore) {
      bestScore = dist2;
      bestMover = m;
    }
  });

  // 2) fallback: nearest primary cut by distance if no overlap
  if (!bestMover) {
    primaryCuts.forEach(cutInfo => {
      const m = moverByElement.get(cutInfo.el);
      if (!m) return;

      const ccx = cutInfo.bb.x + cutInfo.bb.width / 2;
      const ccy = cutInfo.bb.y + cutInfo.bb.height / 2;
      const dx = center.x - ccx;
      const dy = center.y - ccy;
      const dist2 = dx * dx + dy * dy;

      if (dist2 < bestScore) {
        bestScore = dist2;
        bestMover = m;
      }
    });
  }

  if (bestMover) {
    // âœ… attach Bart (and other engraves) to the mover
    bestMover.members.push(info.el);
    bestMover.memberBaseTransforms.set(
      info.el,
      info.el.getAttribute("transform") || ""
    );

    // make sure DOM is marked so drag code picks it up
    info.el.classList.add("mover-member");
    info.el.setAttribute("data-mover-id", bestMover.id);
    // engraves should not be individually draggable:
    info.el.style.pointerEvents = "none";
  } else {
    // nothing suitable â†’ leave frozen
    info.el.classList.remove("mover-member");
    info.el.removeAttribute("data-mover-id");
    info.el.style.pointerEvents = "none";
  }
});


  // 3) merge movers when CUT outlines overlap (ignore engraves for merging)
  function moverCutBBox(m) {
    let bb = null;
    m.members.forEach(el => {
      if (el.getAttribute("data-cut-line") === "true") {
        const thisBB = safeBBox(el);
        if (thisBB) {
          bb = unionBBox(bb, thisBB);
        }
      }
    });
    return bb;
  }

  let changed = true;
  while (changed) {
    changed = false;
    outer_merge: for (let i = 0; i < movers.length; i++) {
      for (let j = i + 1; j < movers.length; j++) {
        const a = movers[i];
        const b = movers[j];
        if (!a.hasCut || !b.hasCut) continue;

        const cutA = moverCutBBox(a);
        const cutB = moverCutBBox(b);
        if (!cutA || !cutB) continue;

        if (bboxesOverlap(cutA, cutB)) {
          a.members = a.members.concat(b.members);
          b.members.forEach(el => {
            if (!a.memberBaseTransforms.has(el)) {
              a.memberBaseTransforms.set(
                el,
                b.memberBaseTransforms.get(el) || ""
              );
            }
          });
          // baseBBox is still cut-only (union of cut boxes)
          a.baseBBox = unionBBox(a.baseBBox, b.baseBBox);
          movers.splice(j, 1);
          changed = true;
          break outer_merge;
        }
      }
    }
  }

  markMoverHandles();
}





/* --- choose a single handle element per mover --- */
function markMoverHandles() {
  movers.forEach(m => {
    let handleEl = null;
    let maxArea = -1;

    m.members.forEach(el => {
      const isCut = el.getAttribute('data-cut-line') === 'true';
      if (!isCut) return;
      const bb = safeBBox(el);
      if (!bb) return;
      const area = bb.width * bb.height;
      if (area > maxArea) {
        maxArea = area;
        handleEl = el;
      }
    });

    if (!handleEl) {
      m.members.forEach(el => {
        const bb = safeBBox(el);
        if (!bb) return;
        const area = bb.width * bb.height;
        if (area > maxArea) {
          maxArea = area;
          handleEl = el;
        }
      });
    }

    m.members.forEach(el => {
      el.dataset.moverId = String(m.id);

      if (el === handleEl) {
        el.classList.add('mover-member');
        el.setAttribute('pointer-events', 'bounding-box');
        el.onmousedown = moverMouseDown;
      } else {
        el.classList.remove('mover-member');
        el.setAttribute('pointer-events', 'none');
        el.onmousedown = null;
      }
    });
  });
}

/* ---------- debug ---------- */

function moversDebugString() {
  if (!finalSVG) return "No finalSVG.\n";
  if (!movers || !movers.length) return "No movers.\n";

  let outStr = `Sheet: ${sheetW} x ${sheetH} mm\nMover count: ${movers.length}\n\n`;

  movers.forEach(m => {
    outStr += `Mover #${m.id} (hasCut=${!!m.hasCut})\n`;
    outStr += `  baseBBox: x=${m.baseBBox.x.toFixed(2)}, y=${m.baseBBox.y.toFixed(2)}, w=${m.baseBBox.width.toFixed(2)}, h=${m.baseBBox.height.toFixed(2)}\n`;
    outStr += `  tx=${(m.tx||0).toFixed(2)}, ty=${(m.ty||0).toFixed(2)}\n`;
    outStr += `  members (${m.members.length}):\n`;

    m.members.forEach(el => {
      const tag = el.tagName.toLowerCase();
      const id  = el.id ? `#${el.id}` : "";
      const cut = el.getAttribute("data-cut-line") === "true" ? " CUT" : "";
      const fromImg = el.getAttribute("data-from-image") ? " IMG" : "";
      const dLen = el.getAttribute("d") ? ` dLen=${el.getAttribute("d").length}` : "";
      outStr += `    - <${tag}${id}>${cut}${fromImg}${dLen}\n`;
    });

    outStr += `\n`;
  });

  return outStr;
}

function copyMoversDebugToClipboard() {
  const text = moversDebugString();
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text).then(
      () => alert("Mover debug info copied to clipboard. Paste it into ChatGPT."),
      err => {
        console.error(err);
        alert("Failed to copy debug info. Check console; text logged there.");
        console.log(text);
      }
    );
  } else {
    alert("Clipboard API not available. Debug text printed to console.");
    console.log(text);
  }
}

/* ---------- bottom-left packing ---------- */

function packBottomLeft() {
  if (!movers.length) return;

  const order = movers.slice().sort((a,b) => {
    const areaA = a.baseBBox.width * a.baseBBox.height;
    const areaB = b.baseBBox.width * b.baseBBox.height;
    return areaB - areaA;
  });

  const placed = [];

  for (const m of order) {
    const w = m.baseBBox.width;
    const h = m.baseBBox.height;

    const xs = [0];
    placed.forEach(p => {
      const xCandidate = p.x + p.width;
      if (xCandidate + w <= sheetW + 1e-6) xs.push(xCandidate);
    });

    let bestX = 0, bestY = Infinity;

    xs.forEach(x => {
      let y = 0;
      placed.forEach(p => {
        const overlapX = !(x + w <= p.x || p.x + p.width <= x);
        if (overlapX) {
          y = Math.max(y, p.y + p.height);
        }
      });
      if (y < bestY || (y === bestY && x < bestX)) {
        bestY = y;
        bestX = x;
      }
    });

    m.tx = bestX - m.baseBBox.x;
    m.ty = bestY - m.baseBBox.y;

    placed.push({ x: bestX, y: bestY, width: w, height: h, mover: m });
  }

  movers.forEach(m => applyMoverTransform(m));
}

function applyMoverTransform(m) {
  m.members.forEach(el => {
    const base = m.memberBaseTransforms.get(el) || "";
    const translatePart = `translate(${m.tx}, ${m.ty})`;
    const finalTransform = base
      ? `${base} ${translatePart}`
      : translatePart;
    el.setAttribute("transform", finalTransform.trim());
  });
}

/* ---------- fit layout ---------- */

function fitLayoutIntoSheet() {
  if (!movers.length) return true;

  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;

  movers.forEach(m => {
    const x = m.baseBBox.x + (m.tx || 0);
    const y = m.baseBBox.y + (m.ty || 0);
    const w = m.baseBBox.width;
    const h = m.baseBBox.height;

    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x + w > maxX) maxX = x + w;
    if (y + h > maxY) maxY = y + h;
  });

  const usedW = maxX - minX;
  const usedH = maxY - minY;

  const canFit = (usedW <= sheetW && usedH <= sheetH);

  const shiftX = -minX;
  const shiftY = -minY;

  movers.forEach(m => {
    m.tx += shiftX;
    m.ty += shiftY;
    applyMoverTransform(m);
  });

  return canFit;
}

/* ---------- packing orchestration ---------- */

function doPacking(silent = false, fromResize = false) {
  if (!finalSVG) {
    if (!silent) alert("No SVG loaded yet.");
    return;
  }

  const svgEl = finalSVG;
  const rootContainer = svgEl;

  propagateTransforms(rootContainer);
  explodeGroupsToShapes(rootContainer);
  stripEditorAttrs(svgEl);
  buildMoversFromOverlap(rootContainer);

  if (!movers.length) {
    if (!silent) alert("No shapes/images/text found to pack.");
    return;
  }

  packBottomLeft();
  const canFit = fitLayoutIntoSheet();

  if (fromResize && !canFit && !silent) {
    alert("Sheet is too small for all parts; some will extend beyond the boundary.");
  }

  if (!silent) {
    alert("Packing complete.");
    packBtn.textContent = "Re-pack Now";
  }

  updateResizeHandle();
}

function repackExisting(silent = true, fromResize = true) {
  if (!movers.length) return;
  packBottomLeft();
  const canFit = fitLayoutIntoSheet();
  if (fromResize && !canFit && !silent) {
    alert("Sheet is too small for all parts; some will extend beyond the boundary.");
  }
  updateResizeHandle();
}

/* ---------- mover dragging + snapping ---------- */

function moverMouseDown(e) {
  if (!finalSVG) return;
  e.preventDefault();
  e.stopPropagation();

  const el = e.currentTarget;
  const id = +el.dataset.moverId;
  const m = movers.find(mm => mm.id === id);
  if (!m) return;

  setSelectedMover(m);

  const mouseSVG = clientToSVG(finalSVG, e.clientX, e.clientY);

  const curBox = {
    x: m.baseBBox.x + (m.tx || 0),
    y: m.baseBBox.y + (m.ty || 0)
  };

  dragState = {
    mover: m,
    mouseOffset: {
      x: mouseSVG.x - curBox.x,
      y: mouseSVG.y - curBox.y
    }
  };

  window.addEventListener('mousemove', moverMouseMove);
  window.addEventListener('mouseup', moverMouseUp);
}

function moverMouseMove(e) {
  if (!dragState || !finalSVG) return;
  e.preventDefault();

  const mouseSVG = clientToSVG(finalSVG, e.clientX, e.clientY);
  const m = dragState.mover;

  const boxX = mouseSVG.x - dragState.mouseOffset.x;
  const boxY = mouseSVG.y - dragState.mouseOffset.y;

  m.tx = boxX - m.baseBBox.x;
  m.ty = boxY - m.baseBBox.y;

  applyMoverTransform(m);
}

function moverMouseUp(e) {
  if (!dragState) return;
  e.preventDefault();

  const m = dragState.mover;
  snapMoverToNeighbours(m);
  applyMoverTransform(m);

  dragState = null;
  window.removeEventListener('mousemove', moverMouseMove);
  window.removeEventListener('mouseup', moverMouseUp);
}

function snapMoverToNeighbours(m) {
  const snapTol = 20;

  const mBox = {
    x: m.baseBBox.x + m.tx,
    y: m.baseBBox.y + m.ty,
    width: m.baseBBox.width,
    height: m.baseBBox.height
  };
  const mLeft = mBox.x;
  const mRight = mBox.x + mBox.width;
  const mTop = mBox.y;
  const mBottom = mBox.y + mBox.height;

  let bestDx = 0, bestDxScore = Infinity;
  let bestDy = 0, bestDyScore = Infinity;

  const scoreX = (d, kind) => {
    let s = Math.abs(d);
    if (kind === "shape") s -= 1.0;
    if (kind === "sheet") s -= 0.3;
    if (d < 0) s -= 0.2;
    return s;
  };

  const scoreY = (d, kind) => {
    let s = Math.abs(d);
    if (kind === "shape") s -= 1.0;
    if (kind === "sheet") s -= 0.3;
    if (d < 0) s -= 0.2;
    return s;
  };

  movers.forEach(n => {
    if (n === m) return;
    const nBox = {
      x: n.baseBBox.x + (n.tx || 0),
      y: n.baseBBox.y + (n.ty || 0),
      width: n.baseBBox.width,
      height: n.baseBBox.height
    };
    const nLeft = nBox.x;
    const nRight = nBox.x + nBox.width;
    const nTop = nBox.y;
    const nBottom = nBox.y + nBox.height;

    let dX = nLeft - mRight;
    if (Math.abs(dX) < snapTol) {
      const s = scoreX(dX, "shape");
      if (s < bestDxScore) { bestDxScore = s; bestDx = dX; }
    }
    dX = nRight - mLeft;
    if (Math.abs(dX) < snapTol) {
      const s = scoreX(dX, "shape");
      if (s < bestDxScore) { bestDxScore = s; bestDx = dX; }
    }

    let dY = nTop - mBottom;
    if (Math.abs(dY) < snapTol) {
      const s = scoreY(dY, "shape");
      if (s < bestDyScore) { bestDyScore = s; bestDy = dY; }
    }
    dY = nBottom - mTop;
    if (Math.abs(dY) < snapTol) {
      const s = scoreY(dY, "shape");
      if (s < bestDyScore) { bestDyScore = s; bestDy = dY; }
    }
  });

  let dX = 0 - mLeft;
  if (Math.abs(dX) < snapTol) {
    const s = scoreX(dX, "sheet");
    if (s < bestDxScore) { bestDxScore = s; bestDx = dX; }
  }
  dX = sheetW - mRight;
  if (Math.abs(dX) < snapTol) {
    const s = scoreX(dX, "sheet");
    if (s < bestDxScore) { bestDxScore = s; bestDx = dX; }
  }

  let dY = 0 - mTop;
  if (Math.abs(dY) < snapTol) {
    const s = scoreY(dY, "sheet");
    if (s < bestDyScore) { bestDyScore = s; bestDy = dY; }
  }
  dY = sheetH - mBottom;
  if (Math.abs(dY) < snapTol) {
    const s = scoreY(dY, "sheet");
    if (s < bestDyScore) { bestDyScore = s; bestDy = dY; }
  }

  if (bestDxScore < Infinity || bestDyScore < Infinity) {
    m.tx += bestDx;
    m.ty += bestDy;
  }
}

/* ---------- resizable sheet ---------- */

function addResizeHandle() {
  if (!finalSVG) return;
  let handle = finalSVG.querySelector('#resizeHandle');
  if (!handle) {
    handle = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    handle.id = 'resizeHandle';
    handle.classList.add('resize-handle');
    handle.setAttribute('width', 8);
    handle.setAttribute('height', 8);
    handle.setAttribute('fill', '#c00');
    handle.setAttribute('stroke', '#c00');
    handle.setAttribute('stroke-width', '0.5');
    handle.style.cursor = 'se-resize';
    finalSVG.appendChild(handle);
    handle.addEventListener('mousedown', startSheetResize);
  }
  updateResizeHandle();
}

function updateResizeHandle() {
  if (!finalSVG) return;
  const handle = finalSVG.querySelector('#resizeHandle');
  if (!handle) return;
  const size = 8;
  handle.setAttribute('x', sheetW - size);
  handle.setAttribute('y', sheetH - size);
}

function startSheetResize(e) {
  if (!finalSVG) return;
  e.preventDefault();
  e.stopPropagation();

  const pt = clientToSVG(finalSVG, e.clientX, e.clientY);
  resizeState = {
    startMouse: pt,
    startW: sheetW,
    startH: sheetH
  };

  window.addEventListener('mousemove', doSheetResize);
  window.addEventListener('mouseup', stopSheetResize);
}

function doSheetResize(e) {
  if (!resizeState || !finalSVG) return;
  e.preventDefault();

  const pt = clientToSVG(finalSVG, e.clientX, e.clientY);
  const dx = pt.x - resizeState.startMouse.x;
  const dy = pt.y - resizeState.startMouse.y;

  const minSize = 50;
  let newW = resizeState.startW + dx;
  let newH = resizeState.startH + dy;

  newW = Math.max(minSize, newW);
  newH = Math.max(minSize, newH);

  newW = Math.round(newW / 5) * 5;
  newH = Math.round(newH / 5) * 5;

  sheetW = newW;
  sheetH = newH;

  finalSVG.setAttribute('width', sheetW + "mm");
  finalSVG.setAttribute('height', sheetH + "mm");
  finalSVG.setAttribute('viewBox', `0 0 ${sheetW} ${sheetH}`);

  document.getElementById('w').value = sheetW;
  document.getElementById('h').value = sheetH;

  updateResizeHandle();
}

function stopSheetResize(e) {
  if (!resizeState) return;
  e.preventDefault();
  resizeState = null;

  window.removeEventListener('mousemove', doSheetResize);
  window.removeEventListener('mouseup', stopSheetResize);

  repackExisting(true, true);
}

/* ---------- export helpers ---------- */

function getFileBaseName() {
  const name = requireStudentName();
  if (!name) return null;
  let base = name.trim();
  base = base.replace(/[^\w\-]+/g, '_');
  return `${base}_${sheetW}x${sheetH}mm`;
}

function prepareExportSVG() {
  if (!finalSVG) return null;

  const exportSVG = finalSVG.cloneNode(true);

  const handle = exportSVG.querySelector('#resizeHandle');
  if (handle) handle.remove();

  exportSVG.querySelectorAll('[data-cut-line="true"]').forEach(el => {
    const rawStyle = el.getAttribute('style') || '';
    if (rawStyle) {
      const cleaned = rawStyle
        .split(';')
        .map(s => s.trim())
        .filter(chunk =>
          chunk &&
          !chunk.startsWith('stroke-width') &&
          !chunk.startsWith('stroke:') &&
          !chunk.startsWith('stroke-opacity') &&
          !chunk.startsWith('fill:')
        )
        .join(';');
      if (cleaned.trim()) el.setAttribute('style', cleaned);
      else el.removeAttribute('style');
    }

    el.removeAttribute('stroke-width');
    el.removeAttribute('stroke-opacity');
    el.removeAttribute('fill');

    el.setAttribute('stroke', '#ff0000');
    el.setAttribute('stroke-opacity', '1');
    el.setAttribute('fill', 'none');
    el.setAttribute('stroke-width', EXPORT_CUT_WIDTH);
    el.setAttribute('vector-effect', 'non-scaling-stroke');
  });

  exportSVG.setAttribute('width', sheetW + 'mm');
  exportSVG.setAttribute('height', sheetH + 'mm');
  exportSVG.setAttribute('viewBox', `0 0 ${sheetW} ${sheetH}`);

  return exportSVG;
}

/* ---------- SVG download ---------- */

function downloadFinalSVG() {
  if (!finalSVG) return;
  const baseName = getFileBaseName();
  if (!baseName) return;

  const exportSVG = prepareExportSVG();
  if (!exportSVG) return;

  const xml = '<?xml version="1.0" encoding="UTF-8"?>\n' +
              new XMLSerializer().serializeToString(exportSVG);

  const blob = new Blob([xml], {type:'image/svg+xml'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url;
  a.download = baseName + '.svg';
  a.click();
  URL.revokeObjectURL(url);
}

/* ---------- PDF download ---------- */

async function downloadPDF() {
  if (!finalSVG) return;

  const baseName = getFileBaseName();
  if (!baseName) return;

  if (!window.jspdf || !window.jspdf.jsPDF || !window.svg2pdf) {
    alert("PDF libraries not loaded. Check your internet connection or host jsPDF/svg2pdf locally.");
    return;
  }

  const exportSVG = prepareExportSVG();
  if (!exportSVG) return;

  const mmToPt = mm => mm * 72 / 25.4;
  const widthMm  = sheetW;
  const heightMm = sheetH;
  const widthPt  = mmToPt(widthMm);
  const heightPt = mmToPt(heightMm);

  const orientation = widthPt > heightPt ? "l" : "p";
  const { jsPDF } = window.jspdf;

  try {
    const pdf = new jsPDF({
      orientation,
      unit: "pt",
      format: [widthPt, heightPt],
    });

    await pdf.svg(exportSVG, {
      x: 0,
      y: 0,
      width: widthPt,
      height: heightPt
    });

    pdf.save(baseName + ".pdf");
  } catch (err) {
    console.error(err);
    alert("Error generating PDF. See console for details.");
  }
}

/* ---------- image â†’ vector (merge to single path) ---------- */

async function vectoriseImages(silent = false) {
  if (!finalSVG) return;
  if (typeof ImageTracer === 'undefined' || !ImageTracer.imagedataToSVG) {
    if (!silent) alert("ImageTracer library not loaded.");
    return;
  }

  const images = Array.from(finalSVG.querySelectorAll('image'));
  if (!images.length) {
    if (!silent) alert('No images to vectorise.');
    return;
  }

  for (const imgEl of images) {
    let href = imgEl.getAttribute('href') || imgEl.getAttribute('xlink:href');
    if (!href || !href.startsWith('data:image')) continue;

    const imgBB = safeBBox(imgEl);
    if (!imgBB || !imgBB.width || !imgBB.height) continue;

    const bitmap = await loadImage(href);

    const canvas = document.createElement('canvas');
    canvas.width = bitmap.width;
    canvas.height = bitmap.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(bitmap, 0, 0);

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

    const options = {
      numberofcolors: 6,
      ltres: 1,
      qtres: 1,
      pathomit: 1,
      blurradius: 1,
      blurdelta: 20
    };

    const svgString = ImageTracer.imagedataToSVG(imageData, options);
    const tmpDoc    = new DOMParser().parseFromString(svgString, 'image/svg+xml');
    const tracedSvg = tmpDoc.querySelector('svg');
    if (!tracedSvg) continue;

    function fillBrightness(fill) {
      if (!fill) return 1;
      fill = fill.trim().toLowerCase();

      if (fill === 'black') return 0;
      if (fill === 'white') return 1;

      let r, g, b;

      const hexMatch = fill.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
      if (hexMatch) {
        let hex = hexMatch[1];
        if (hex.length === 3) {
          hex = hex.split('').map(c => c + c).join('');
        }
        const intVal = parseInt(hex, 16);
        r = (intVal >> 16) & 255;
        g = (intVal >> 8)  & 255;
        b =  intVal        & 255;
      } else {
        const rgbMatch = fill.match(/rgb\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*\)/);
        if (rgbMatch) {
          r = parseFloat(rgbMatch[1]);
          g = parseFloat(rgbMatch[2]);
          b = parseFloat(rgbMatch[3]);
        } else {
          return 1;
        }
      }
      return (r + g + b) / (3 * 255);
    }

    const BRIGHTNESS_THRESHOLD = 0.7;

    const keptPaths = [];

    Array.from(tracedSvg.children).forEach(child => {
      const tag = child.tagName ? child.tagName.toLowerCase() : '';
      if (tag !== 'path') return;

      const fill = (child.getAttribute('fill') || '').trim().toLowerCase();
      const bright = fillBrightness(fill);
      if (bright > BRIGHTNESS_THRESHOLD) {
        return;
      }

      child.setAttribute('fill', '#000000');
      child.removeAttribute('stroke');
      child.removeAttribute('stroke-width');
      child.removeAttribute('transform');

      const d = child.getAttribute('d');
      if (d && d.trim()) {
        keptPaths.push(d.trim());
      }
    });

    if (!keptPaths.length) {
      continue;
    }

    const mergedPathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
    mergedPathEl.setAttribute('d', keptPaths.join(' '));
    mergedPathEl.setAttribute('fill', '#000000');
    mergedPathEl.setAttribute('data-from-image', 'true');

    finalSVG.appendChild(mergedPathEl);

    const vectBB = safeBBox(mergedPathEl);
    if (!vectBB || !vectBB.width || !vectBB.height) {
      mergedPathEl.remove();
      continue;
    }

    const sx = imgBB.width  / vectBB.width;
    const sy = imgBB.height / vectBB.height;

    const tx1 = -vectBB.x;
    const ty1 = -vectBB.y;
    const tx2 =  imgBB.x;
    const ty2 =  imgBB.y;

    const groupTransform =
      `translate(${tx2},${ty2}) scale(${sx},${sy}) translate(${tx1},${ty1})`;

    mergedPathEl.setAttribute('transform', groupTransform);

    imgEl.remove();
  }

  if (!silent) {
    alert('Images vectorised to black engravings.');
  }
}

function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}
</script>
</body>
</html>
